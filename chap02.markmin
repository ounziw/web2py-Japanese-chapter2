
## Python言語
``Python``:inxx

### Pythonについて
Pythonは高水準で凡用性の高いプログラミング言語です。開発者の生産性と可読性に重きを置いて設計されています。 その設計思想は、プログラマの生産性とコードの読みやすさを強調しています。簡単なセマンティックと基礎的なコマンドを最小限の核となる構文を持ちます。一方で、大規模で総括的な標準ライブラリを有し、多くのオペレーティングシステム(OS)の機能を基礎としたアプリケーション・プログラム・インターフェース(API)を含んでいます。Pythonのコードは最小主義ですが、リンクリスト(``list``)、タプル(``tuple``)、ハッシュテーブル(``dict``)、任意長の整数(``long``)などの組み込みオブジェクトを定義しています。
Python is a general-purpose high-level programming language.
Its design philosophy emphasizes programmer productivity and code readability. It has a minimalist core syntax with very few basic commands and simple semantics, but it also has a large and comprehensive standard library, including an Application Programming Interface (API) ``API``:inxx to many of the underlying operating system (OS) functions. Python code, while minimalist, defines built-in objects such as linked lists (``list``), tuples (``tuple``), hash tables (``dict``), and arbitrarily long integers (``long``).

Pythonは、オブジェクト指向(``class``)、命令型(``def``)、関数型(``lambda``)などの複数のプログラミングパラダイムをサポートしています。動的型付けシステムと、参照カウントを利用した自動メモリ管理を有しています(Ruby、Perl、Schemeと同様です)。
Python supports multiple programming paradigms, including object-oriented (``class``), imperative (``def``), and functional (``lambda``) programming. Python has a dynamic type system and automatic memory management using reference counting (similar to Perl, Ruby, and Scheme).

Pythonは、1991年にGuido Van Rossumによって初めてリリースされました。非営利のPythonソフトウェア財団が管理する、オープンなコミュニティベースの開発モデルになっています。Python言語を実装している多くのインタプリタとコンパイラがあります。1つはJava(Jython)によるものですが、ここでの簡単な説明ではGuidoによって開発されたC実装に言及します。
Python was first released by Guido van Rossum in 1991. The language has an open, community-based development model managed by the non-profit Python Software Foundation. There are many interpreters and compilers that implement the Python language, including one in Java (Jython) but, in this brief review, we refer to the reference C implementation created by Guido.

PythonのオフィシャルWebサイト``python``:citeでは多くのチュートリアル、ライブラリーリファレンスや公式ドキュメントを見ることができます。
You can find many tutorials, the official documentation and library references of the language on the official Python website.``python``:cite

上記のドキュメントに加えて、参照``guido``:citeや参照``lutz``:citeといった書籍も参考になるかもしれません。
For additional Python references, we can recommend the books in ref.``guido``:cite  and ref.``lutz``:cite .

すでにPython言語に精通している場合は、本章を飛ばしてもかまわないでしょう。
You may skip this chapter if you are already familiar with the Python language.

### Starting up
``shell``:inxx
Microsoft WindowsやMac版のweb2pyのバイナリ配布は、Pythonのインタープリターを同梱しています。
The binary distributions of web2py for Microsoft Windows or Apple OS X come packaged with the Python interpreter built into the distribution file itself.

以下のように(DOSプロンプトで)入力するとWindows上で起動することができます。
You can start it on Windows with the following command (type at the DOS prompt):
``
web2py.exe -S welcome
``:code

Mac OSXでは、ターミナルウィンドウで以下のコマンドを入力します(web2py.appと同じフォルダにいる必要があります)。
On Apple OS X, enter the following command type in a Terminal window (assuming you're in the same folder as web2py.app):
``
./web2py.app/Contents/MacOS/web2py -S welcome
``:code

Linuxや他のUnixコンピュータでは、Pythonがすでにインストールされているかを確認し、以下のようにシェルコマンドを入力してください。
On a Linux or other Unix box, chances are that you have Python already installed. If so, at a shell prompt type:
``
python web2py.py -S welcome
``:code

もしPython2.5以降がインストールされていない場合は、web2pyを起動する前にpythonのダウンロードとインストールが必要です。
If you do not have Python 2.5 (or later 2.x) already installed, you will have to download and install it before running web2py.

``-S welcome``は、**welcome**アプリケーションのコントローラー内でコマンドが実行されているかのように、対話型のシェルを動作することをweb2pyに指示します。web2pyの対話型のコマンドラインと通常のPythonコマンドラインの違いはこれだけです。
The ``-S welcome`` command line option instructs web2py to run the interactive shell as if the commands were executed in a controller for the **welcome** application, the web2py scaffolding application. This exposes almost all web2py classes, objects and functions to you. This is the only difference between the web2py interactive command line and the normal Python command line.

管理インターフェースはアプリケーション毎にWebベースのシェルを提供します。次のURLで"welcome"アプリケーション用のシェルにアクセスできます。
The admin interface also provides a web-based shell for each application. You can access the one for the "welcome" application at.
``
http://127.0.0.1:8000/admin/shell/index/welcome
``:code

本章におけるすべての例題は、通常のシェルかWebベースのシェルで試すことができます。
You can try all the examples in this chapter using the normal shell or the web-based shell.

### help, dir
``help``:inxx ``dir``:inxx

Python言語には、組み込みおよびユーザ定義両方の現在のスコープにおいて、定義されたオブジェクトに関するドキュメントを取得する2つのコマンドが用意されています。
The Python language provides two commands to obtain documentation about objects defined in the current scope, both built-in and user-defined.

たとえば"1"というオブジェクトに関するhelpを尋ねることができます：
We can ask for ``help`` about an object, for example "1":
``
>>> help(1)
Help on int object:

class int(object)
 |  int(x[, base]) -> integer
 |
 |  Convert a string or number to an integer, if possible.  A floating point
 |  argument will be truncated towards zero (this does not include a string
 |  representation of a floating point number!)  When converting a string, use
 |  the optional base.  It is an error to supply a base when converting a
 |  non-string. If the argument is outside the integer range a long object
 |  will be returned instead.
 |
 |  Methods defined here:
 |
 |  __abs__(...)
 |      x.__abs__() <==> abs(x)
...
``:code

"1"は整数なので、intクラスとそのすべてのメソッドに関する説明が得られます。上記の例では出力結果が長いため、切り取られています。
and, since "1" is an integer, we get a description about the ``int`` class and all its methods. Here the output has been truncated because it is very long and detailed.

同様に、dirコマンドを用いることで、"1"オブジェクトのメソッドのリストを得ることができます。
Similarly, we can obtain a list of methods of the object "1" with the command ``dir``:
``
>>> dir(1)
['__abs__', '__add__', '__and__', '__class__', '__cmp__', '__coerce__',
'__delattr__', '__div__', '__divmod__', '__doc__', '__float__',
'__floordiv__', '__getattribute__', '__getnewargs__', '__hash__', '__hex__',
'__index__', '__init__', '__int__', '__invert__', '__long__', '__lshift__',
'__mod__', '__mul__', '__neg__', '__new__', '__nonzero__', '__oct__',
'__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdiv__',
'__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__',
'__rlshift__', '__rmod__', '__rmul__', '__ror__', '__rpow__', '__rrshift__',
'__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__',
'__str__', '__sub__', '__truediv__', '__xor__']
``:code

### 型
``type``:inxx
Pythonは動的型付け言語です。つまり、変数に特定の型はなく、それゆえ宣言する必要がありません。一方で、値は特定の型を持っています。以下のようにして、変数に対して、そこに格納された値の型について問い合わせることができます。
Python is a dynamically typed language, meaning that variables do not have a type and therefore do not have to be declared. Values, on the other hand, do have a type. You can query a variable for the type of value it contains:
``
>>> a = 3
>>> print type(a)
<type 'int'>
>>> a = 3.14
>>> print type(a)
<type 'float'>
>>> a = 'hello python'
>>> print type(a)
<type 'str'>
``:code

Pythonはまた、最初からリストや辞書などのデータ構造を内包しています。
Python also includes, natively, data structures such as lists and dictionaries.

#### ``str``
``str``:inxx ``ASCII``:inxx ``UTF8``:inxx ``Unicode``:inxx ``encode``:inxx

Pythonは、ASCII文字列とUnicode文字列の2つの異なる型の文字列の使用をサポートしています。ASCII文字列は'...'、"..."、'''..'''、"""..."""で区切られたものです。トリプルクォートは、複数行の文字列を区切ります。Unicode文字列は``u``で始まり、Unicode文字列がその後に続きます。次のようにエンコーディングを選択することで、Unicode文字列をASCII文字列に変換することができます。
Python supports the use of two different types of strings: ASCII strings and Unicode strings. ASCII strings are delimited by '...', "..." or by '''..''' or """...""". Triple quotes delimit multiline strings. Unicode strings start with a ``u`` followed by the string containing Unicode characters. A Unicode string can be converted into an ASCII string by choosing an encoding for example:
``
>>> a = 'this is an ASCII string'
>>> b = u'This is a Unicode string'
>>> a = b.encode('utf8')
``:code

上記のコマンド実行により、``a``の結果はUTF8でエンコードされた文字列を格納するASCII文字列になります。web2pyは意図的に、UTF8でエンコードされた文字列を内部で使用します。
After executing these three commands, the resulting ``a`` is an ASCII string storing UTF8 encoded characters. By design, web2py uses UTF8 encoded strings internally.

また、さまざまな方法で、変数を文字列で記述することが可能です：
It is also possible to write variables into strings in various ways:
``
>>> print 'number is ' + str(3)
number is 3
>>> print 'number is %s' % (3)
number is 3
>>> print 'number is %(number)s' % dict(number=3)
number is 3
``:code

最後の表記はより明示的でエラーが起きにくいので、推奨される書き方です。
The last notation is more explicit and less error prone, and is to be preferred.

多くのPythonオブジェクトは、たとえば数字は、``str``または``repr``を用いて文字列にシリアライズすることができます。これら2つのコマンドは非常に似ていますが、若干異なる出力結果を生成します。例：
Many Python objects, for example numbers, can be serialized into strings using ``str`` or ``repr``. These two commands are very similar but produce slightly different output. For example:
``
>>> for i in [3, 'hello']:
        print str(i), repr(i)
3 3
hello 'hello'
``:code

ユーザー定義クラスにおいて、``str``や``repr``は``__str__``と``__repr__``という特別な演算子を用いて定義/再定義できます。これらは後ほど簡単に説明します。より詳細についてはPython公式ドキュメント``pydocs``:citeを参照してください。なお、``repr``は常に​​デフォルトの値を持っています 。
For user-defined classes, ``str`` and ``repr`` can be defined/redefined using the special operators ``__str__`` and ``__repr__``. These are briefly described later on; for more, refer to the official Python documentation``pydocs``:cite . ``repr`` always has a default value.

Python文字列のもう1つの重要な特徴は、リストのように反復可能なオブジェクトであるという点です。
Another important characteristic of a Python string is that, like a list, it is an iterable object.
``
>>> for i in 'hello':
        print i
h
e
l
l
o
``:code

#### ``list``
``list``:inxx

Pythonリストの主要なメソッドは追加(append)、挿入(insert)、削除(delete)です：
The main methods of a Python list are append, insert, and delete:
``
>>> a = [1, 2, 3]
>>> print type(a)
<type 'list'>
>>> a.append(8)
>>> a.insert(2, 7)
>>> del a[0]
>>> print a
[2, 7, 3, 8]
>>> print len(a)
4
``:code

リストは次のようにスライスできます：
Lists can be sliced:
``
>>> print a[:3]
[2, 7, 3]
>>> print a[1:]
[7, 3, 8]
>>> print a[-2:]
[3, 8]
``:code

連結することも可能です：
and concatenated:
``
>>> a = [2, 3]
>>> b = [5, 6]
>>> print a + b
[2, 3, 5, 6]
``:code

リストは反復可能です。つまり、それをループで回すことができます：
A list is iterable; you can loop over it:
``
>>> a = [1, 2, 3]
>>> for i in a:
        print i
1
2
3
``:code

リストの要素は同じ型にする必要はありません。任意のPythonオブジェクトをとることができます。
The elements of a list do not have to be of the same type; they can be any type of Python object.

''list comprehension''を使用できる典型的な状況があります。次のコードを考えて見ましょう。
There is a very common situation for which a ''list comprehension'' can be used.  Consider the following code:
``
>>> a = [1,2,3,4,5]
>>> b = []
>>> for x in a:
        if x % 2 == 0:
            b.append(x * 3)
>>> b
[6, 12]
``:code

このコードはアイテムリストを処理し、入力リストのサブセットを選択、編集し、新しい結果のリストを作成しています。このコードは次のようにリスト内包表記で完全に置き換えられます。
This code clearly processes a list of items, selects and modifies a subset of the input list, and creates a new result list, and this code can be entirely replaced with the following list comprehension:
``
>>> a = [1,2,3,4,5]
>>> b = [x * 3 for x in a if x % 2 == 0]
>>> b
[6, 12]
``:code

#### ``tuple``
``tuple``:inxx

タプルはリストに似ていますが、そのサイズと要素は、リストは変更可能なのに対し、タプルは変更不可能です。タプルの要素がオブジェクトである場合、オブジェクトの属性は変更可能です。タプルは丸括弧で区切られます。
A tuple is like a list, but its size and elements are immutable, while in a list they are mutable. If a tuple element is an object, the object attributes are mutable. A tuple is delimited by round brackets.
``
>>> a = (1, 2, 3)
``:code

したがって、以下のコードはリストに対しては動作しますが、
So while this works for a list:
``
>>> a = [1, 2, 3]
>>> a[1] = 5
>>> print a
[1, 5, 3]
``:code

タプルに対しては、要素の割り当てが機能しません。
the element assignment does not work for a tuple:
``
>>> a = (1, 2, 3)
>>> print a[1]
2
>>> a[1] = 5
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
``:code

タプルはリストと同様に反復可能なオブジェクトです。注意として、単一の要素でタプルを構成する際は、以下のように末尾にコンマをつけなければいけません：
A tuple, like a list, is an iterable object. Notice that a tuple consisting of a single element must include a trailing comma, as shown below:
``
>>> a = (1)
>>> print type(a)
<type 'int'>
>>> a = (1,)
>>> print type(a)
<type 'tuple'>
``:code

タプルはその不変性と括弧の利用が省略可能であることから、オブジェクトを効率的に格納するのにとても便利です。
Tuples are very useful for efficient packing of objects because of their immutability, and the brackets are often optional:
``
>>> a = 2, 3, 'hello'
>>> x, y, z = a
>>> print x
2
>>> print z
hello
``:code

#### ``dict``
``dict``:inxx

Pythonの``dict``-ionary(辞書)はキーオブジェクトを値オブジェクトにマッピングするハッシュテーブルです。例:
A Python ``dict``-ionary is a hash table that maps a key object to a value object. For example:
``
>>> a = {'k':'v', 'k2':3}
>>> a['k']
v
>>> a['k2']
3
>>> a.has_key('k')
True
>>> a.has_key('v')
False
``:code

キーは任意の型のハッシュ可能な型(int、string、他、``__hash__``メソッド実装したクラスのオブジェクト)をとることができます。値は任意の型を使用できます。同じ辞書内の異なるキーと値は、同じ型にする必要はありません。キーが英数字の場合は、辞書は次のような代替の構文を用いて宣言することができます：
Keys can be of any hashable type (int, string, or any object whose class implements the ``__hash__`` method). Values can be of any type. Different keys and values in the same dictionary do not have to be of the same type. If the keys are alphanumeric characters, a dictionary can also be declared with the alternative syntax:
``
>>> a = dict(k='v', h2=3)
>>> a['k']
v
>>> print a
{'k':'v', 'h2':3}
``:code

便利なメソッドは、``has_key``、 ``keys``、``values``、``items`` です。
Useful methods are ``has_key``, ``keys``, ``values`` and ``items``:
``
>>> a = dict(k='v', k2=3)
>>> print a.keys()
['k', 'k2']
>>> print a.values()
['v', 3]
>>> print a.items()
[('k', 'v'), ('k2', 3)]
``:code

``items``メソッドはタプルのリストを生成し、各タプルはキーとそれに対応付けられた値を格納しています。
The ``items`` method produces a list of tuples, each containing a key and its associated value.

辞書の要素とリストの要素は、``del``コマンドで削除することができます。
Dictionary elements and list elements can be deleted with the command ``del``:
``
>>> a = [1, 2, 3]
>>> del a[1]
>>> print a
[1, 3]
>>> a = dict(k='v', h2=3)
>>> del a['h2']
>>> print a
{'k':'v'}
``:code

内部的には、Pythonは、``hash``演算子でオブジェクトを整数に変換し、その整数によってどこに値を格納するかを決めています。
Internally, Python uses the ``hash`` operator to convert objects into integers, and uses that integer to determine where to store the value.
``
>>> hash("hello world")
-1500746465
``:code

### インデントについて

Pythonはインデントをコードブロックの区切りに利用しています。ブロック1つはコロンで終了する行から始まって、同じかそれより高いインデントが次の行として現れるまで続きます。例：
Python uses indentation to delimit blocks of code. A block starts with a line ending in colon, and continues for all lines that have a similar or higher indentation as the next line. For example:
``
>>> i = 0
>>> while i < 3:
>>>    print i
>>>    i = i + 1
>>>
0
1
2
``:code

各インデントのレベルには4つのスペースを使うのが一般的です。 (不可視の)混乱を招かないように、スペースとタブを混在しないことが得策です。
It is common to use four spaces for each level of indentation.
It is a good policy not to mix tabs with spaces, which can result in (invisible) confusion.

### ``for...in``
``for``:inxx
Pythonでは反復可能なオブジェクトをループで回すことができます。
In Python, you can loop over iterable objects:
``
>>> a = [0, 1, 'hello', 'python']
>>> for i in a:
        print i
0
1
hello
python
``:code

``xrange``は一般的なショートカットの1つで、すべてのリスト要素を格納せずに、反復可能な範囲オブジェクトを生成します。
One common shortcut is ``xrange``,
which generates an iterable range without storing the entire list of elements.
``
>>> for i in xrange(0, 4):
        print i
0
1
2
3
``:code

これは、次のC / C + + / C＃の/ Javaの構文と等価です：
This is equivalent to the C/C++/C#/Java syntax:
``
for(int i=0; i<4; i=i+1) { print(i); }
``:code

もう1つの有用なコマンドは``enumerate``です。次のようにカウントしながらループ処理を行います：
Another useful command is ``enumerate``, which counts while looping:
``
>>> a = [0, 1, 'hello', 'python']
>>> for i, j in enumerate(a):
        print i, j
0 0
1 1
2 hello
3 python
``:code

また、``range(a, b, c)``というキーワードがあります。これは、``a``で始まり``c``ずつ増加し、``b``より小さい最後の値で終わる整数のリストを返します。``a``はデフォルト値で0で、``c``はデフォルトで1です。xrangeも似ていますが実際にリストを作ることはなく、そのリストに対するイテレータを生成します。これはループ処理にとってより良いです。
There is also a keyword ``range(a, b, c)`` that returns a list of integers starting with the value ``a``, incrementing by ``c``, and ending with the last value smaller than ``b``,  ``a`` defaults to 0 and ``c`` defaults to 1. ``xrange`` is similar but does not actually generate the list, only an iterator over the list; thus it is better for looping.

``break``を利用してループから抜けることができます。
You can jump out of a loop using ``break``
``
>>> for i in [1, 2, 3]:
         print i
         break
1
``:code

``continue``を利用して、すべてのコードブロックを実行せずに、次のループ処理へ飛ぶことができます：
You can jump to the next loop iteration without executing the entire code block with ``continue``
``
>>> for i in [1, 2, 3]:
         print i
         continue
         print 'test'
1
2
3
``:code

### ``while``
``while``:inxx
Pythonにおいて``while``ループは他の多くのプログラミング言語と同じように、無限にループ処理を行い、また、各反復の前に条件のテストを行います。条件が``False``になると、ループは終わります。
The ``while`` loop in Python works much as it does in many other programming languages, by looping an indefinite number of times and testing a condition before each iteration. If the condition is ``False``, the loop ends.
``
>>> i = 0
>>> while i < 10:
        i = i + 1
>>> print i
10
``:code

Pythonでは``loop...until``の構造は存在しません。
There is no ``loop...until`` construct in Python.

### ``if...elif...else``
``if``:inxx ``elif``:inxx ``else``:inxx
Pythonにおける条件文の使用は直感的です：
The use of conditionals in Python is intuitive:
``
>>> for i in range(3):
>>>     if i == 0:
>>>         print 'zero'
>>>     elif i == 1:
>>>         print 'one'
>>>     else:
>>>         print 'other'
zero
one
other
``:code

"elifは""else if"の意味です。``elif``句と``else``句はどちらも省略可能です。``elif``は何回も利用可能ですが、``else``は一度だけです。 複雑な条件文は``not``、``and``、``or``の演算子を利用し作成することができます。
"elif" means "else if". Both ``elif`` and ``else`` clauses are optional. There can be more than one ``elif`` but only one ``else`` statement. Complex conditions can be created using the ``not``, ``and`` and ``or`` operators.
``
>>> for i in range(3):
>>>     if i == 0 or (i == 1 and i + 1 == 2):
>>>         print '0 or 1'
``:code

### ``try...except...else...finally``
``try``:inxx ``except``:inxx ``finally``:inxx ``Exception``:inxx
Pythonは、割り込みを投げる、例外を起こすことができます:
Python can throw - pardon, raise - Exceptions:
``
>>> try:
>>>     a = 1 / 0
>>> except Exception, e:
>>>     print 'oops: %s' % e
>>> else:
>>>     print 'no problem here'
>>> finally:
>>>     print 'done'
oops: integer division or modulo by zero
done
``:code

例外が発生したときは、``except``句で補足され、その句が実行されますが、``else``句は実行されません。例外が発生しなかった場合は、``except``句は実行されず、``else``句が実行されます。``finally``句は常に実行されます。
If the exception is raised, it is caught by the ``except`` clause, which is executed, while the ``else`` clause is not. If no exception is raised, the ``except`` clause is not executed, but the ``else`` one is. The ``finally`` clause is always executed.

異なる例外が発生する可能性があるために複数の``except``句をとることができます:
There can be multiple ``except`` clauses for different possible exceptions:
``
>>> try:
>>>     raise SyntaxError
>>> except ValueError:
>>>     print 'value error'
>>> except SyntaxError:
>>>     print 'syntax error'
syntax error
``:code

``else``句と``finally``句は省略可能です。
The ``else`` and ``finally`` clauses are optional.

以下は、組み込みのPython例外のリストと(web2pyで定義されている)HTTP例外です。
Here is a list of built-in Python exceptions + HTTP (defined by web2py)
``
BaseException
 +-- HTTP (defined by web2py)
 +-- SystemExit
 +-- KeyboardInterrupt
 +-- Exception
      +-- GeneratorExit
      +-- StopIteration
      +-- StandardError
      |    +-- ArithmeticError
      |    |    +-- FloatingPointError
      |    |    +-- OverflowError
      |    |    +-- ZeroDivisionError
      |    +-- AssertionError
      |    +-- AttributeError
      |    +-- EnvironmentError
      |    |    +-- IOError
      |    |    +-- OSError
      |    |         +-- WindowsError (Windows)
      |    |         +-- VMSError (VMS)
      |    +-- EOFError
      |    +-- ImportError
      |    +-- LookupError
      |    |    +-- IndexError
      |    |    +-- KeyError
      |    +-- MemoryError
      |    +-- NameError
      |    |    +-- UnboundLocalError
      |    +-- ReferenceError
      |    +-- RuntimeError
      |    |    +-- NotImplementedError
      |    +-- SyntaxError
      |    |    +-- IndentationError
      |    |         +-- TabError
      |    +-- SystemError
      |    +-- TypeError
      |    +-- ValueError
      |    |    +-- UnicodeError
      |    |         +-- UnicodeDecodeError
      |    |         +-- UnicodeEncodeError
      |    |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
	   +-- ImportWarning
	   +-- UnicodeWarning
``:code

各項目の詳細については、Python公式ドキュメントを参照してください。
For a detailed description of each of them, refer to the official Python documentation.

web2pyは、``HTTP``と呼ばれる新しい例外を1つだけ公開しています。その例外が発生すると、プログラムはHTTPエラーページを返すようになります(詳細は第4章を参照してください)。
web2py exposes only one new exception, called ``HTTP``. When raised, it causes the program to return an HTTP error page (for more on this refer to Chapter 4).

任意のオブジェクトは例外として発生させることができますが、それには組み込みのexceptionクラスを拡張したオブジェクトの利用を推奨します。
Any object can be raised as an exception, but it is good practice to raise objects that extend one of the built-in exception classes.

### ``def...return``
``def``:inxx ``return``:inxx

関数は``def``を使って宣言されます。以下は典型的なPythonの関数です。
Functions are declared using ``def``.  Here is a typical Python function:
``
>>> def f(a, b):
        return a + b
>>> print f(4, 2)
6
``:code

引数や戻り値の型を指定する必要（または方法）はありません。この例では関数``f``は2つの引数を取るように定義されています。
There is no need (or way) to specify types of the arguments or the return type(s). In this example, a function ``f`` is defined that can take two arguments.

関数はこの章で初めて''scope''や''namespace''という概念を紹介する記述です。上記の例で、``a``と``b``の変数は``f``関数のスコープの外では未定義になります。
Functions are the first code syntax feature described in this chapter to introduce the concept of ''scope'', or ''namespace''.  In the above example, the identifiers ``a`` and ``b`` are undefined outside of the scope of function ``f``:
``
>>> def f(a):
        return a + 1
>>> print f(1)
2
>>> print a
Traceback (most recent call last):
  File "<pyshell#22>", line 1, in <module>
    print a
NameError: name 'a' is not defined
``:code

関数のスコープの外で定義された変数は関数内でも使用可能です;次の例で変数``a``がどのように扱われているかを検証してみてください。
Identifiers defined outside of function scope are accessible within the function; observe how the identifier ``a`` is handled in the following code:
``
>>> a = 1
>>> def f(b):
        return a + b
>>> print f(1)
2
>>> a = 2
>>> print f(1) # new value of a is used
3
>>> a = 1 # reset a
>>> def g(b):
        a = 2 # creates a new local a
        return a + b
>>> print g(2)
4
>>> print a # global a is unchanged
1
``:code

もし``a``が編集されると、後続の関数はグローバル変数``a``の値を使用します。これは関数定義が宣言時の変数``a``の値ではなく、変数``a``の保管場所と紐づいているためです。しかし、``g``関数内部で``a``が割り振られた場合、新しいローカル変数``a``がグローバルの値を隠すため、グローバル変数``a``は影響を受けません。外部スコープ参照は''closures''の作成で実現できます。
If ``a`` is modified, subsequent function calls will use the new value of the global ``a`` because the function definition binds the storage location of the identifier ``a``, not the value of ``a`` itself at the time of function declaration; however, if ``a`` is assigned-to inside function ``g``, the global ``a`` is unaffected because the new local ``a`` hides the global value.  The external-scope reference can be used in the creation of ''closures'':
``
>>> def f(x):
        def g(y):
            return x * y
        return g
>>> doubler = f(2) # doubler is a new function
>>> tripler = f(3) # tripler is a new function
>>> quadrupler = f(4) # quadrupler is a new function
>>> print doubler(5)
10
>>> print tripler(5)
15
>>> print quadrupler(5)
20
``:code

関数``f``が新しい関数を作成し、``g``のスコープは完全に``f``の内部にあります。Closuresは非常に強力です。
Function ``f`` creates new functions; and note that the scope of the name ``g`` is entirely internal to ``f``.  Closures are extremely powerful.

関数の引数はデフォルト値を取ることができ、複数の結果を返すことができます。
Function arguments can have default values, and can return multiple results:
``
>>> def f(a, b=2):
        return a + b, a - b
>>> x, y = f(5)
>>> print x
7
>>> print y
3
``:code

引数を明示的に名称で渡すこともできます。これは呼び出し側で指定された引数の順序が関数で定義された引数の順序と異なってもよいことを意味します。
Function arguments can be passed explicitly by name, and this means that the order of arguments specified in the caller can be different than the order of arguments with which the function was defined:
``
>>> def f(a, b=2):
        return a + b, a - b
>>> x, y = f(b=5, a=2)
>>> print x
7
>>> print y
-3
``:code

関数はまた、可変数の引数を取ることができます。
Functions can also take a runtime-variable number of arguments:
``
>>> def f(*a, **b):
        return a, b
>>> x, y = f(3, 'hello', c=4, test='world')
>>> print x
(3, 'hello')
>>> print y
{'c':4, 'test':'world'}
``:code

ここで、名前付きで渡されなかった引数（3、'hello'）はリスト``a``に格納され、名前付きで渡された(``c``と``test``)は辞書``b``に格納されます。
Here arguments not passed by name (3, 'hello') are stored in the tuple ``a``, and arguments passed by name (``c`` and ``test``) are stored in the dictionary ``b``.

逆に、リストやタプルは、展開しながら、個別の位置引数を要求する関数に渡すことができます：
In the opposite case, a list or tuple can be passed to a function that requires individual positional arguments by unpacking them:
``
>>> def f(a, b):
        return a + b
>>> c = (1, 2)
>>> print f(*c)
3
``:code

辞書もまた、展開しながら、キーワード引数に引き渡すことができます。
and a dictionary can be unpacked to deliver keyword arguments:
``
>>> def f(a, b):
        return a + b
>>> c = {'a':1, 'b':2}
>>> print f(**c)
3
``:code

#### ``lambda``
``lambda``:inxx

``lambda``を使用することでとても簡単で簡潔な無名関数を作成することができます。
``lambda`` provides a way to create a very short unnamed function very easily:
``
>>> a = lambda b: b + 2
>>> print a(3)
5
``:code

"lambda [a]：[b]"式は、文字通り"引数[a]を持ち[b]を返す関数"として読みます。``lambda``式自体は無名関数ですが、変数に保存されることで名前を獲得しています。``def``のスコープの法則は``lambda``にも同様に適用され、上記の例にある``a``に関していうと``def``を使った関数宣言と全く同じです。
The expression "``lambda`` [a]:[b]" literally reads as "a function with arguments [a] that returns [b]". The ``lambda`` expression is itself unnamed, but the function acquires a name by being assigned to identifier ``a``.  The scoping rules for ``def`` apply to ``lambda`` equally, and in fact the code above, with respect to ``a``, is identical to the function declaration using ``def``:
``
>>> def a(b):
        return b + 2
>>> print a(3)
5
``:code

``lambda``の長所はその簡潔さだけです。しかし、簡潔さはある状況で非常に便利です。リスト上の要素全てに関数を適用し新しいリストを作成する``map``という名前の関数を考えて見ましょう。
The only benefit of ``lambda`` is brevity; however, brevity can be very convenient in certain situations.  Consider a function called ``map`` that applies a function to all items in a list, creating a new list:
``
>>> a = [1, 7, 2, 5, 4, 8]
>>> map(lambda x: x + 2, a)
[3, 9, 4, 7, 6, 10]
``:code

``lambda``の代わりに``def``を使用した場合、コード量は2倍になります。``lambda``の主な欠点（Pythonの実装で）は単一式しか許可しない点です。長い記述の関数の場合は関数名を指定する手間のある``def``使用することで、関数の記述量が増えていっても対応できます。
``def``や``lambda``が関数を''curry''（ネスト）することができるように、既存の関数を包括した新しい関数を作成することで新しい関数が異なる変数セットを持つことができます。
This code would have doubled in size had ``def`` been used instead of ``lambda``. The main drawback of ``lambda`` is that (in the Python implementation) the syntax allows only for a single expression; however, for longer functions, ``def`` can be used and the extra cost of providing a function name decreases as the length of the function grows.
Just like ``def``, ``lambda`` can be used to ''curry'' functions: new functions can be created by wrapping existing functions such that the new function carries a different set of arguments:
``
>>> def f(a, b): return a + b
>>> g = lambda a: f(a, 3)
>>> g(2)
5
``:code

関数をネストすることが便利な状況はいろいろありますが、以下で挙げるキャッシュの例はweb2pyで特に便利な使用方法です。引数が素数であるかを確認する高負荷な関数を考えて見ましょう。
There are many situations where currying is useful, but one of those is directly useful in web2py: caching. Suppose you have an expensive function that checks whether its argument is prime:
``
def isprime(number):
    for p in range(2, number):
        if (number % p) == 0:
            return False
    return True
``:code

この関数は明らかに多くの時間を必要とします。
This function is obviously time consuming.

key、関数、秒数の3つの引数を受け取る``cache.ram``というキャッシュ関数があると仮定しましょう。
Suppose you have a caching function ``cache.ram`` that takes three arguments: a key, a function and a number of seconds.
``
value = cache.ram('key', f, 60)
``:code

初回の実行時は、``f()``関数を呼び出し、メモリ上の辞書（仮に"d"とします）に結果を保存し値を返します。このため値は以下のようになります。
The first time it is called, it calls the function ``f()``, stores the output in a dictionary in memory (let's say "d"), and returns it so that value is:
``
value = d['key']=f()
``:code

2回目の実行時は、もしkeyが辞書に存在し、指定された秒数(60)よりデータが古くない場合、関数を実行しないで対応する値を返します。
The second time it is called, if the key is in the dictionary and not older than the number of seconds specified (60), it returns the corresponding value without performing the function call.
``
value = d['key']
``:code

入力値に対応する**isprime**関数の結果をキャッシュするにはどのようにすればよいでしょうか？
これは以下のようになります:
How would you cache the output of the function **isprime** for any input?
Here is how:
``
>>> number = 7
>>> seconds = 60
>>> print cache.ram(str(number), lambda: isprime(number), seconds)
True
>>> print cache.ram(str(number), lambda: isprime(number), seconds)
True
``:code

結果は同じですが、初回に``cache.ram``が実行された場合だけ``isprime``が呼ばれ、2回目は呼ばれません。
The output is always the same, but the first time ``cache.ram`` is called, ``isprime`` is called; the second time it is not.

-------
``def``や``lambda``で作成されたPython関数は異なる引数の組み合わせの観点から既存の関数をリファクタリングすることができます。``cache.ram``と``cache.disk``はweb2pyのキャッシュ関数です。
Python functions, created with either ``def`` or ``lambda`` allow re-factoring existing functions in terms of a different set of arguments.
``cache.ram`` and ``cache.disk`` are web2py caching functions.
-------

### ``class``
``class``:inxx

Pythonは動的型付けなので、Pythonのクラスとオブジェクトは少し変わったものに見えるかもしれません。実際、クラスを宣言する際にメンバ変数(属性)を必ずしも定義する必要はなく、同じクラスから作られた異なるインスタンスはそれぞれ違うメンバ変数(属性)を持つことができます。一般的に属性は、クラスではなくインスタンスに関連付けられます(ただし、クラス属性として宣言された場合は別です。これはC++/Javaでの"静的メンバ変数と同じです)。
Because Python is dynamically typed, Python classes and objects may seem odd. In fact, you do not need to define the member variables (attributes) when declaring a class, and different instances of the same class can have different attributes. Attributes are generally associated with the instance, not the class (except when declared as "class attributes", which is the same as "static member variables" in C++/Java).

例を示します：
Here is an example:
``
>>> class MyClass(object): pass
>>> myinstance = MyClass()
>>> myinstance.myvariable = 3
>>> print myinstance.myvariable
3
``:code

ここで、``pass``は何もしないというコマンドであることに注意してください。この場合、何も含んでいない``MyClass``というクラスを定義するために用いられています。``MyClass()``はクラスのコンストラクタを呼び出し(この場合、デフォルトのコンストラクタ)、オブジェクト、つまり、このクラスのインスタンスを返します。クラス定義における``(object)``の部分は、このクラスが組み込みの``object``クラスを拡張したものであることを示しています。これは必須ではないですが、推奨される書き方です。
Notice that ``pass`` is a do-nothing command. In this case it is used to define a class ``MyClass`` that contains nothing. ``MyClass()`` calls the constructor of the class (in this case the default constructor) and returns an object, an instance of the class. The ``(object)`` in the class definition indicates that our class extends the built-in ``object`` class. This is not required, but it is good practice.

次により複雑なクラスの例を示します：
Here is a more complex class:
``
>>> class MyClass(object):
>>>    z = 2
>>>    def __init__(self, a, b):
>>>        self.x = a, self.y = b
>>>    def add(self):
>>>        return self.x + self.y + self.z
>>> myinstance = MyClass(3, 4)
>>> print myinstance.add()
9
``:code

クラスの内部で定義された関数はメソッドになります。いくつかのメソッドは、特別な予約済みの名前を持ちます。たとえば、``__init__``はコンストラクタです。すべての変数は、メソッドの外で定義されたものでない限り、メソッドのローカル変数です。たとえば、``z``はクラス変数です。これは、C++の静的メンバ変数と同じで、そのクラスのすべてのインスタンスに対して同じ値を保持します。
Functions declared inside the class are methods. Some methods have special reserved names. For example, ``__init__`` is the constructor. All variables are local variables of the method except variables declared outside methods. For example, ``z`` is a ''class variable'', equivalent to a C++ ''static member variable'' that holds the same value for all instances of the class.

ここで、``__init__``は3つの引数をとり、``add``は1つの引数をとっているのに対し、それらはそれぞれ2つの引数と、0個の引数によって呼ばれている点に注意してください。最初の引数は、慣例的に、メソッド内で利用されるローカルな名前を示していて、現在のオブジェクトを参照します。ここでは、``self``を現在のオブジェクトを参照するのに利用しています。ただし、任意の他の名前を用いることも可能です。``self``はC++の``*this``やJavaの``this``と同じ役割を担います。ただし、``self``は予約語ではありません。

Notice that ``__init__`` takes 3 arguments and ``add`` takes one, and yet we call them with 2 and 0 arguments respectively. The first argument represents, by convention, the local name used inside the method to refer to the current object. Here we use ``self`` to refer to the current object, but we could have used any other name. ``self`` plays the same role as ``*this`` in C++ or ``this`` in Java, but ``self`` is not a reserved keyword.

この構文は、ネストしたクラス、たとえばあるクラス内のメソッドにおいてローカルなクラス、を宣言するときに、曖昧さを避けるために必要です。
This syntax is necessary to avoid ambiguity when declaring nested classes, such as a class that is local to a method inside another class.

### 特殊属性、メソッド、演算子

2つのアンダスコアから始まるクラス属性、メソッド、演算子は、一般にプライベート（クラス内でのみ使用し、クラス外から呼び出されない）であることを意図しますが、これはインタプリタによって強制される慣例ではありません。
Class attributes, methods, and operators starting with a double underscore are usually intended to be private (i.e. to be used internally but not exposed outside the class) although this is a convention that is not enforced by the interpreter.

そのうちのいくつかは予約されたキーワードで、特別な意味を持っています。
Some of them are reserved keywords and have a special meaning.

例として、そのなかの3つを示します。
Here, as an example, are three of them:
- ``__len__``
- ``__getitem__``
- ``__setitem__``
これらは、たとえば、リストのように振舞うコンテナオブジェクトの作成に利用できます：
They can be used, for example, to create a container object that acts like a list:
``
>>> class MyList(object):
>>>     def __init__(self, *a): self.a = list(a)
>>>     def __len__(self): return len(self.a)
>>>     def __getitem__(self, i): return self.a[i]
>>>     def __setitem__(self, i, j): self.a[i] = j
>>> b = MyList(3, 4, 5)
>>> print b[1]
4
>>> b.a[1] = 7
>>> print b.a
[3, 7, 5]
``:code

他の特殊演算子としては、クラスにおいて属性の取得と設定を定義する``__getattr__``と``__setattr__``や、算術演算子をオーバーロードする``__sum__``や``__sub__``などがあります。 これらの演算子の利用についてもっと知りたい場合は、より高度な書籍を参照してください。また、``__str__``と``__repr__``演算子についてはすでに言及してあります。
Other special operators include ``__getattr__`` and ``__setattr__``, which define the get and set attributes for the class, and ``__sum__`` and ``__sub__``, which overload arithmetic operators. For the use of these operators we refer the reader to more advanced books on this topic. We have already mentioned the special operators ``__str__`` and ``__repr__``.

### ファイル入力/出力
``file.read``:inxx ``file.write``:inxx

Pythonでは、以下のようにしてファイルを開き、書き込むことができます。
In Python you can open and write in a file with:
``
>>> file = open('myfile.txt', 'w')
>>> file.write('hello world')
>>> file.close()
``:code

同様に、以下のようにしてファイルを読み出すことができます。
Similarly, you can read back from the file with:
``
>>> file = open('myfile.txt', 'r')
>>> print file.read()
hello world
``:code

もう一つの方法として、"rb"を用いてバイナリモードで読むことが可能で、"wb"を用いてバイナリモードで書き込むことが可能です。さらに、追記モード"a"においてファイルを開くこともできます。標準のC言語表記と同じです。
Alternatively, you can read in binary mode with "rb", write in binary mode with "wb", and open the file in append mode "a", using standard C notation.

``read``コマンドは省略可能な引数であるバイト数を取ります。また、ファイル内の任意の箇所に飛ぶ場合は、``seek``を利用します。
The ``read`` command takes an optional argument, which is the number of bytes. You can also jump to any location in a file using ``seek``.
``file.seek``:inxx

``read``を利用して飛んだ場所からファイルを読むことができます。
You can read back from the file with ``read``
``
>>> print file.seek(6)
>>> print file.read()
world
``:code

ファイルを閉じるときは次のようにします。
and you can close the file with:
``
>>> file.close()
``:code

-------
CPythonとして知られるPythonの標準実装では、変数は参照カウントを使用しており、使用しているファイルもこれで扱っています。このため、CPythonは参照カウントの開いているファイル数がゼロになると、ファイルはクローズされていると判断し変数を破棄します。しかしPyPyなどの別の実装では参照カウントの代わりにガベージコレクションが使用されます。これはもし大量のファイルが一度にオープンされた場合、''gc''（ガベージコレクション）がそれをクローズして破棄する前にはエラーが発生する可能性があります。このため、もう使用しない場合は明示的にファイルをクローズするのが推奨されます。''web2py''は``read_file()``と``write_file()``の2つのヘルパ関数を提供します。これは``gluon.fileutils``名前空間の内部でファイルアクセスをカプセル化し、使用されたファイルが適切にクローズされているかを確認します。
In the standard distribution of Python, which is known as CPython, variables are reference-counted, including those holding file handles, so CPython knows that when the reference count of an open file handle decreases to zero, the file may be closed and the variable disposed.  However, in other implementations of Python such as PyPy, garbage collection is used instead of reference counting, and this means that it is possible that there may accumulate too many open file handles at one time, resulting in an error before the ''gc'' has a chance to close and dispose of them all.  Therefore it is best to explicitly close file handles when they are no longer needed.  ''web2py'' provides two helper functions, ``read_file()`` and ``write_file()`` inside the ``gluon.fileutils`` namespace that encapsulate the file access and ensure that the file handles being used are properly closed.
-------

-------
web2pyを使用している場合、カレントディレクトリの場所を知る必要はありません。なぜなら、それはweb2pyの設定に依存するからです。``request.folder``変数は、現在のアプリケーションへのパスを保持しています。パスは、後述する``os.path.join``コマンドによって連結することができます。
When using web2py, you do not know where the current directory is, because it depends on how web2py is configured. The variable ``request.folder`` contains the path to the current application. Paths can be concatenated with the command ``os.path.join``, discussed below.
-------

### ``exec``, ``eval``
``exec``:inxx ``eval``:inxx

Javaと異なり、Pythonは真のインタプリンタ言語です。つまり、文字列として格納されたPythonコードを実行する能力があります。例:
Unlike Java, Python is a truly interpreted language. This means it has the ability to execute Python statements stored in strings. For example:
``
>>> a = "print 'hello world'"
>>> exec(a)
'hello world'
``:code

何が起こったのでしょうか？関数``exec``は、インタープリンタに自分自身を呼び出すように命令し、引数として渡された文字列の中身を実行します。また、辞書のシンボルによって定義されたコンテキストの中で、文字列の中身を実行することも可能です：
What just happened? The function ``exec`` tells the interpreter to call itself and execute the content of the string passed as argument. It is also possible to execute the content of a string within a context defined by the symbols in a dictionary:
``
>>> a = "print b"
>>> c = dict(b=3)
>>> exec(a, {}, c)
3
``:code

ここでは、インタプリタが、文字列``a``を実行したときに、``c``で定義されたシンボル(この例では``b``)を参照しています。ただし、``c``や``a``自身を参照することはありません。これは制限された環境とは大きく異なります。execは内部コードができることに制限を加えないからです。コードが利用出来る変数セットを単に定義しているだけです。
Here the interpreter, when executing the string ``a``, sees the symbols defined in ``c`` (``b`` in the example), but does not see ``c`` or ``a`` themselves. This is different than a restricted environment, since ``exec`` does not limit what the inner code can do; it just defines the set of variables visible to the code.

関連する関数として``eval``があります。これは、``exec``と非常に似た動きをしますが、評価される引数が値になることを想定し、その値を返すという点で異なります。
A related function is ``eval``, which works very much like ``exec`` except that it expects the argument to evaluate to a value, and it returns that value.
``
>>> a = "3*4"
>>> b = eval(a)
>>> print b
12
``:code

### ``import``
``import``:inxx ``random``:inxx
Pythonoが本当に強力なのは、そのライブラリモジュールがあるからです。それらは、大規模で一貫性のあるアプリケーション・プログラム・インターフェース(API)を多くの（大抵オペレーティング・システムから独立した）システムライブラリに提供します。
The real power of Python is in its library modules. They provide a large and consistent set of Application Programming Interfaces (APIs) to many system libraries (often in a way independent of the operating system).

たとえば、乱数ジェネレーターを利用する必要がある場合、次のようにします：
For example, if you need to use a random number generator, you can do:
``
>>> import random
>>> print random.randint(0, 9)
5
``:code

この例では、0から9の間のランダムな整数を表示します(ここでは5が表示されています)。``randint``関数は``random``モジュール内で定義されています。モジュールからオブジェクトを現在の名前空間にインポートすることも可能です：
This prints a random integer between 0 and 9 (including 9), 5 in the example. The function ``randint`` is defined in the module ``random``. It is also possible to import an object from a module into the current namespace:
``
>>> from random import randint
>>> print randint(0, 9)
``:code

もしくは、モジュールからすべてのオブジェクトを現在の名前空間にインポートすることも可能です：
or import all objects from a module into the current namespace:
``
>>> from random import *
>>> print randint(0, 9)
``:code

さらに、すべてを新しく定義した名前空間にインポートすることも可能です：
or import everything in a newly defined namespace:
``
>>> import random as myrand
>>> print myrand.randint(0, 9)
``:code

本書の残りの部分では、 ``os``、``sys``、``datetime``、``time``、``cPickle``といったモジュールに定義されたオブジェクトをよく利用します。
In the rest of this book, we will mainly use objects defined in modules ``os``, ``sys``, ``datetime``, ``time`` and ``cPickle``.

-------
すべてのweb2pyオブジェクトは、``gluon``と呼ばれるモジュールを介してアクセスすることができます。これは、後述の章にて扱います。内部的には、web2pyは多くのPythonモジュール(たとえば``thread``など)を使用しています。しかし、利用者が直接それらにアクセスする必要はほとんどないでしょう。
All of the web2py objects are accessible via a module called ``gluon``, and that is the subject of later chapters. Internally, web2py uses many Python modules (for example ``thread``), but you rarely need to access them directly.
-------

以下の小節では、最も利用されるそれらのモジュールを考えます。
In the following subsections we consider those modules that are most useful.

#### ``os``
``os``:inxx ``os.path.join``:inxx ``os.unlink``:inxx

このモジュールは、オペレーティング・システムAPIへのインターフェイスを提供します。例：
This module provides an interface to the operating system API. For example:
``
>>> import os
>>> os.chdir('..')
>>> os.unlink('filename_to_be_deleted')
``:code

-------
``chdir``のような``os``のいくつかの関数は、web2pyのおいて使用しないでください。スレッドセーフではないからです。
Some of the ``os`` functions, such as ``chdir``, MUST NOT be used in web2py because they are not thread-safe.
-------
``os.path.join``はとても便利で、OSに依存しない形でパスの連結が可能になります。
``os.path.join`` is very useful; it allows the concatenation of paths in an OS-independent way:
``
>>> import os
>>> a = os.path.join('path', 'sub_path')
>>> print a
path/sub_path
``:code

システム環境変数はos.environを介してアクセスできます。
System environment variables can be accessed via:
``
>>> print os.environ
``:code

これは読み取り専用の辞書です。
which is a read-only dictionary.

#### ``sys``
``sys``:inxx ``sys.path``:inxx

``sys``モジュールは多くの変数と関数を持ちますが、最も利用するのはsys.pathです。これは、Pythonがモジュールを探すためのパスのリストを保持しています。モジュールをインポートしようとしたとき、Pythonは``sys.path``内にリストされたすべてのフォルダーをチェックします。どこかの場所において追加のモジュールをインストールして、それをPythonに探させたい場合、その場所へのパスを``sys.path``に追加しなければなりません。
The ``sys`` module contains many variables and functions, but the one we use the most is ``sys.path``. It contains a list of paths where Python searches for modules. When we try to import a module, Python looks for it in all the folders listed in ``sys.path``. If you install additional modules in some location and want Python to find them, you need to append the path to that location to ``sys.path``.
``
>>> import sys
>>> sys.path.append('path/to/my/modules')
``:code

web2pyが実行されている時は、Pythonはメモリ内に常駐し、多くのスレッドがHTTPリクエストを処理している一方、sys.pathは1つしかありません。 メモリリークを回避するにためには、パスを追記する前に、それがすでに存在しているかを確認するのが最良です。
When running web2py, Python stays resident in memory, and there is only one ``sys.path``, while there are many threads servicing the HTTP requests. To avoid a memory leak, it is best to check if a path is already present before appending:
``
>>> path = 'path/to/my/modules'
>>> if not path in sys.path:
        sys.path.append(path)
``:code

#### ``datetime``
``date``:inxx ``datetime``:inxx ``time``:inxx

datetimeモジュールの使い方を説明するいくつかの例を紹介します。
The use of the datetime module is best illustrated by some examples:
``
>>> import datetime
>>> print datetime.datetime.today()
2008-07-04 14:03:90
>>> print datetime.date.today()
2008-07-04
``:code

ローカルタイムではなく、UTCタイムに基づいたタイムスタンプデータが必要になるかもしれません。その場合、次のような関数を用いることができます：その場合では、次の関数を使用することができます：
Occasionally you may need to time-stamp data based on the UTC time as opposed to local time. In this case you can use the following function:
``
>>> import datetime
>>> print datetime.datetime.utcnow()
2008-07-04 14:03:90
``:code

datetimeのモジュールには、date、datetime、time、timedeltaなど、さまざまなクラスが含まれています。2つのdate、2つのdatetime、2つのtimeオブジェクト間の差は、timedeltaになります：
The datetime module contains various classes: date, datetime, time and timedelta. The difference between two date or two datetime or two time objects is a timedelta:
``
>>> a = datetime.datetime(2008, 1, 1, 20, 30)
>>> b = datetime.datetime(2008, 1, 2, 20, 30)
>>> c = b - a
>>> print c.days
1
``:code

web2pyにおいて、dateとdatetimeは、データベースへ渡すときや戻されるときに、対応するSQLの型を格納するのに利用されます。
In web2py, date and datetime are used to store the corresponding SQL types when passed to or returned from the database.

#### ``time``
``time``:inxx

timeモジュールは``date``や``datetime``と異なり、(1970年から始まる)エポックからの秒数として時間を表現します。
The time module differs from ``date`` and ``datetime`` because it represents time as seconds from the epoch (beginning of 1970).
``
>>> import time
>>> t = time.time()
1215138737.571
``:code

秒の時間と``datetime``の時間とを変換する関数についてはPythonドキュメントを参照してください。
Refer to the Python documentation for conversion functions between time in seconds and time as a ``datetime``.

#### ``cPickle``
``cPickle``:inxx

cPickleはとても強力なモジュールです。cPickleは自己参照オブジェクトを含む、ほぼすべてのPythonオブジェクトをシリアライズすることができる関数を提供します。たとえば、次のような奇妙なオブジェクトを構築します：
This is a very powerful module. It provides functions that can serialize almost any Python object, including self-referential objects. For example, let's build a weird object:
``
>>> class MyClass(object): pass
>>> myinstance = MyClass()
>>> myinstance.x = 'something'
>>> a = [1 ,2, {'hello':'world'}, [3, 4, [myinstance]]]
``:code

そして以下のようにします：
and now:
``
>>> import cPickle
>>> b = cPickle.dumps(a)
>>> c = cPickle.loads(b)
``:code

ここで、``b``は``a``の文字列表現で、``c``は``b``をデシリアライズして生成されたaのコピーです。
In this example, ``b`` is a string representation of ``a``, and ``c`` is a copy of ``a`` generated by de-serializing ``b``.

cPickleは、ファイルへシリアライズ、ファイルからデシリアライスすることも可能です：
cPickle can also serialize to and de-serialize from a file:
``
>>> cPickle.dump(a, open('myfile.pickle', 'wb'))
>>> c = cPickle.load(open('myfile.pickle', 'rb'))
``:code

##### 第3版 - 翻訳: 細田謙二　レビュー: Omi Chiba
##### 第4版 - 翻訳: Omi Chiba　レビュー: Fumito Mizuno
